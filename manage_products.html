// เพิ่มตัวแปรสำหรับการแคช
let cache = {
  types: null,
  categories: null,
  products: null,
  lastLoaded: {
    types: null,
    categories: null,
    products: null
  }
};

// เพิ่มฟังก์ชันตรวจสอบแคช
function isCacheValid(cacheKey, maxAgeMinutes = 5) {
  if (!cache[cacheKey] || !cache.lastLoaded[cacheKey]) return false;
  
  const now = new Date();
  const cacheTime = new Date(cache.lastLoaded[cacheKey]);
  const diffMinutes = (now - cacheTime) / (1000 * 60);
  
  return diffMinutes < maxAgeMinutes;
}

// ปรับปรุงฟังก์ชัน loadProducts ให้โหลดอย่างมีประสิทธิภาพ
async function loadProducts(forceRefresh = false) {
  try {
    // ใช้แคชถ้ายังไม่หมดอายุและไม่บังคับรีเฟรช
    if (!forceRefresh && isCacheValid('products', 2)) {
      renderProducts(dataList);
      return;
    }
    
    showStatus('กำลังโหลดข้อมูลสินค้า...', 'info');
    
    // ใช้ Promise.all เพื่อโหลดข้อมูลพร้อมกัน
    const [productsRes, typesRes, categoriesRes] = await Promise.allSettled([
      client.from('products').select('*').order('created_at', { ascending: false }),
      client.from('type').select('*').order('name'),
      client.from('category').select('*').order('name')
    ]);
    
    let products = [];
    let types = [];
    let categories = [];
    
    // ดึงข้อมูลผลลัพธ์
    if (productsRes.status === 'fulfilled' && productsRes.value.data) {
      products = productsRes.value.data;
      cache.products = products;
      cache.lastLoaded.products = new Date();
    }
    
    if (typesRes.status === 'fulfilled' && typesRes.value.data) {
      types = typesRes.value.data;
      cache.types = types;
      cache.lastLoaded.types = new Date();
      updateTypeDropdown(types);
    }
    
    if (categoriesRes.status === 'fulfilled' && categoriesRes.value.data) {
      categories = categoriesRes.value.data;
      cache.categories = categories;
      cache.lastLoaded.categories = new Date();
      updateCategoryDropdown(categories);
    }
    
    // แสดงผลบางส่วนก่อน
    renderProducts(products);
    
    // ค่อยๆ อัพเดตข้อมูลเพิ่มเติม
    setTimeout(() => {
      enrichProductsWithMetadata(products, types, categories);
    }, 100);
    
    dataList = products;
    showStatus('โหลดข้อมูลสินค้าเรียบร้อยแล้ว', 'success');
    
  } catch (err) {
    console.error('Exception loading products:', err);
    showStatus('เกิดข้อผิดพลาดในการโหลดข้อมูลสินค้า: ' + err.message, 'error');
  }
}

// ฟังก์ชันเสริมข้อมูลสินค้าด้วยข้อมูลประเภทและหมวดหมู่
async function enrichProductsWithMetadata(products, types, categories) {
  const typeMap = new Map(types.map(t => [t.id, t]));
  const categoryMap = new Map(categories.map(c => [c.id, c]));
  
  products.forEach(product => {
    if (product.category_id && typeMap.has(product.category_id)) {
      product.type_name = typeMap.get(product.category_id).name;
    }
    if (product.type_id && categoryMap.has(product.type_id)) {
      const category = categoryMap.get(product.type_id);
      product.category_name = category.name;
      product.category_code = category.code;
    }
  });
  
  // อัพเดตการแสดงผลเฉพาะแถวที่เปลี่ยน
  updateProductRows(products);
}

// อัพเดต dropdown ประเภทสินค้า
function updateTypeDropdown(types) {
  const select = document.getElementById("type");
  select.innerHTML = '<option value="">เลือกประเภทสินค้า</option>' + 
    types.map(t => `<option value="${t.id}">${t.name}</option>`).join("");
}

// อัพเดต dropdown หมวดหมู่สินค้า
function updateCategoryDropdown(categories) {
  const select = document.getElementById("category");
  select.innerHTML = '<option value="">เลือกหมวดหมู่/แบรนด์</option>' + 
    categories.map(c => `<option value="${c.id}">${c.name}${c.code ? ` (${c.code})` : ''}</option>`).join("");
}

// อัพเดตแถวในตารางแบบค่อยเป็นค่อยไป
function updateProductRows(products) {
  const rows = document.querySelectorAll('#tableBody tr');
  
  rows.forEach((row, index) => {
    if (products[index]) {
      const product = products[index];
      const typeCell = row.cells[5];
      const categoryCell = row.cells[6];
      
      if (typeCell && product.type_name) {
        typeCell.textContent = product.type_name;
      }
      
      if (categoryCell && product.category_name) {
        categoryCell.innerHTML = `${product.category_name}${product.category_code ? `<br><small>(${product.category_code})</small>` : ''}`;
      }
      
      // อัพเดตสไตล์ถ้ามีปัญหา foreign key
      if ((product.category_id && !product.type_name) || (product.type_id && !product.category_name)) {
        row.style.backgroundColor = '#fff3cd';
      } else {
        row.style.backgroundColor = '';
      }
    }
  });
}

// ปรับปรุงฟังก์ชัน renderProducts สำหรับแสดงผลที่เร็วขึ้น
function renderProducts(products) {
  const tableBody = document.getElementById("tableBody");
  
  if (products.length === 0) {
    tableBody.innerHTML = `
      <tr>
        <td colspan="8" style="text-align:center;padding:40px 20px;">
          <div class="empty-state">
            <i class="fas fa-box-open"></i>
            <p>ไม่มีข้อมูลสินค้า</p>
            <button class="success" onclick="showForm()" style="margin-top: 15px;">
              <i class="fas fa-plus-circle"></i>เพิ่มสินค้าแรก
            </button>
          </div>
        </td>
      </tr>`;
    return;
  }
  
  // ใช้ DocumentFragment เพื่อลดการ reflow
  const fragment = document.createDocumentFragment();
  let rowsHTML = '';
  
  // สร้าง HTML แบบ batch
  products.forEach((item, index) => {
    const typeName = item.type_name || '-';
    const categoryName = item.category_name || '-';
    const categoryCode = item.category_code || '';
    const hasForeignKeyIssue = (item.category_id && !item.type_name) || (item.type_id && !item.category_name);
    
    rowsHTML += `
      <tr ${hasForeignKeyIssue ? 'style="background-color:#fff3cd;"' : ''}>
        <td>${item.product_code || '-'}</td>
        <td>
          ${item.image_url ? 
            `<img src="${item.image_url}" class="product-image" onclick="openModal(this)" loading="lazy">` : 
            '<div style="width:60px;height:60px;background:#f0f0f0;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#999;"><i class="fas fa-image"></i></div>'}
        </td>
        <td style="text-align:left;">
          <strong>${item.name}</strong>
          ${item.description ? `<br><small style="color:#666;">${item.description.substring(0, 50)}${item.description.length > 50 ? '...' : ''}</small>` : ''}
          ${hasForeignKeyIssue ? '<br><small style="color:#dc3545;"><i class="fas fa-exclamation-triangle"></i> มีปัญหาการอ้างอิงหมวดหมู่/ประเภท</small>' : ''}
        </td>
        <td>${Number(item.price).toFixed(2)}</td>
        <td>
          <span style="font-weight:bold; color:${item.stock < 10 ? '#dc3545' : item.stock < 20 ? '#fd7e14' : '#28a745'}">
            ${item.stock}
          </span>
        </td>
        <td>${typeName}</td>
        <td>${categoryName}${categoryCode ? `<br><small>(${categoryCode})</small>` : ''}</td>
        <td>
          <div class="action-buttons">
            <button class="warning action-btn" onclick="editItem(${item.id})" title="แก้ไข">
              <i class="fas fa-edit"></i>
            </button>
            <button class="danger action-btn" onclick="deleteItem(${item.id})" title="ลบ">
              <i class="fas fa-trash"></i>
            </button>
            <button class="info action-btn" onclick="viewDetails(${item.id})" title="ดูรายละเอียด">
              <i class="fas fa-eye"></i>
            </button>
            ${hasForeignKeyIssue ? `<button class="light action-btn" onclick="fixSingleProduct(${item.id})" title="ซ่อมแซมการอ้างอิง"><i class="fas fa-wrench"></i></button>` : ''}
          </div>
        </td>
      </tr>
    `;
    
    // แสดงผลเป็นกลุ่มๆ ละ 50 แถวเพื่อลดการ block UI
    if ((index + 1) % 50 === 0 || index === products.length - 1) {
      const tempDiv = document.createElement('tbody');
      tempDiv.innerHTML = rowsHTML;
      fragment.appendChild(tempDiv);
      rowsHTML = '';
    }
  });
  
  tableBody.innerHTML = '';
  tableBody.appendChild(fragment);
}

// ปรับปรุงการค้นหาให้ทำงานแบบ debounce
let searchTimeout;
function setupSearchDebounce() {
  const searchInput = document.getElementById("searchInput");
  
  searchInput.addEventListener('input', () => {
    clearTimeout(searchTimeout);
    
    if (searchInput.value.trim() === '') {
      renderProducts(dataList);
      return;
    }
    
    // รอผู้ใช้พิมพ์เสร็จก่อนค้นหา (300ms)
    searchTimeout = setTimeout(() => {
      searchProducts();
    }, 300);
  });
}

// ปรับปรุงการลบโดยไม่ต้องโหลดข้อมูลทั้งหมดใหม่
async function deleteItem(id) {
  if (!confirm("คุณต้องการลบสินค้านี้หรือไม่?")) return;
  
  try {
    // แสดงสถานะกำลังลบ
    const deleteBtn = document.querySelector(`button[onclick="deleteItem(${id})"]`);
    const originalHTML = deleteBtn.innerHTML;
    deleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    deleteBtn.disabled = true;
    
    const { error } = await client.from('products').delete().eq('id', id);
    
    if (error) {
      showStatus('ลบสินค้าไม่สำเร็จ: ' + error.message, 'error');
      deleteBtn.innerHTML = originalHTML;
      deleteBtn.disabled = false;
      return;
    }
    
    // ลบออกจาก dataList และอัพเดตการแสดงผลโดยไม่โหลดใหม่ทั้งหมด
    const index = dataList.findIndex(item => item.id === id);
    if (index !== -1) {
      dataList.splice(index, 1);
      
      // อัพเดตเฉพาะแถวที่ถูกลบ
      const rows = document.querySelectorAll('#tableBody tr');
      if (rows[index]) {
        rows[index].remove();
      }
      
      // ถ้าไม่เหลือสินค้า ให้แสดง empty state
      if (dataList.length === 0) {
        renderProducts([]);
      }
    }
    
    showStatus('ลบสินค้าเรียบร้อยแล้ว', 'success');
    
  } catch (err) {
    console.error(err);
    showStatus('เกิดข้อผิดพลาดในการลบสินค้า: ' + err.message, 'error');
  }
}

// ปรับปรุงการเพิ่ม/แก้ไขสินค้า
async function addItem() {
  // ปิดปุ่มเพื่อป้องกันการกดซ้ำ
  const addBtn = document.getElementById('addBtn');
  const originalText = addBtn.innerHTML;
  addBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังบันทึก...';
  addBtn.disabled = true;
  
  // ดำเนินการเพิ่มตามปกติ...
  // (โค้ดเดิมของ addItem อยู่ที่นี่)
  
  // เมื่อเสร็จแล้วคืนสถานะปุ่ม
  addBtn.innerHTML = originalText;
  addBtn.disabled = false;
}

// เพิ่ม Intersection Observer สำหรับ lazy loading รูปภาพ
function setupLazyLoading() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        const src = img.getAttribute('data-src');
        if (src) {
          img.src = src;
          img.removeAttribute('data-src');
        }
        observer.unobserve(img);
      }
    });
  }, {
    rootMargin: '50px 0px',
    threshold: 0.1
  });
  
  // ใช้กับรูปภาพใหม่ที่เพิ่มเข้ามา
  const observerForNewImages = new MutationObserver(() => {
    document.querySelectorAll('.product-image[data-src]').forEach(img => {
      observer.observe(img);
    });
  });
  
  observerForNewImages.observe(document.body, {
    childList: true,
    subtree: true
  });
}

// ปรับปรุง initialization
document.addEventListener('DOMContentLoaded', () => {
  // Event listeners
  document.getElementById('showFormBtn').addEventListener('click', () => showForm('add'));
  
  // ตั้งค่า search ด้วย debounce
  setupSearchDebounce();
  
  // ตั้งค่า lazy loading
  setupLazyLoading();
  
  // เมื่อเลือกหมวดหมู่สินค้า ให้สร้างรหัสอัตโนมัติ
  const categorySelect = document.getElementById("category");
  if (categorySelect) {
    categorySelect.addEventListener('change', generateProductCode);
  }
  
  // Load initial data
  loadProducts();
  
  // ปรับปรุงการปิด modal
  window.addEventListener('click', (event) => {
    const modal = document.getElementById("settingsModal");
    if (event.target === modal) {
      closeSettingsModal();
    }
    
    const imageModal = document.getElementById("imageModal");
    if (event.target === imageModal) {
      closeModal();
    }
  });
});

// ฟังก์ชันรีเฟรชใหม่ที่โหลดเฉพาะข้อมูลที่เปลี่ยนแปลง
async function refreshData(force = false) {
  await loadProducts(force);
}

// เปลี่ยนปุ่มรีเฟรชให้ใช้ฟังก์ชันใหม่
document.querySelector('button[onclick="loadProducts()"]').onclick = () => refreshData(true);

// ปรับปรุงการแสดงผล status message
function showStatus(message, type) {
  const statusElement = document.getElementById('statusMessage');
  statusElement.textContent = message;
  statusElement.className = 'status-message ' + type + '-msg';
  statusElement.style.display = 'block';
  
  // ปรับเวลาให้สั้นลงเมื่อเป็นข้อความสำเร็จ
  const timeout = type === 'success' ? 3000 : 6000;
  
  setTimeout(() => {
    statusElement.style.display = 'none';
  }, timeout);
}